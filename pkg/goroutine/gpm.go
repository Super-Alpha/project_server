package goroutine

// Go调度的本质是把大量的goroutine分配到少量的线程Thread上去执行，并利用多核并行，进而实现更强大的并发。

// 在调度器GPM模型中，G是goroutine，P是处理器processor，M是OS线程。其中P是线程和Goroutine的中间层，它能够提供线程需要的上下文环境，也会负责调度线程上的等待队列，

// 通过处理器P的调度，每一个内核线程都能够执行多个Goroutine，能在Goroutine进行一些I/O操作时及时让出计算资源，提高线程的利用率。

// 调度器在启动时就会创建GOMAXPROCS个处理器P，所以Go语言的处理器P的数量一定会等于GOMAXPROCS，这些处理器P会绑定到不同的内核线程上。

/*
调度器设计策略：复用线程，避免频繁的创建、销毁线程，而是对线程的复用。
1、work stealing 机制
	当本线程无可运行的G时，尝试从其他线程绑定的P中窃取G，而不是销毁线程。（当从其他线程偷取不到G时，该线程会从全局G队列获取G）
2、hand off 机制
	当本线程因为系统调用阻塞时，该线程释放绑定的P，并把P转移给其他空闲的线程去执行，若无空闲线程，则创建新线程去执行。
	当G因为网络IO阻塞时，p会将该G挂起，去执行其他G，当IO返回时，p会将G重新加入到队列中，唤醒G的执行。
*/

// 线程是被分割的CPU资源，协程是组织好的代码流程
